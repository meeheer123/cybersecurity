<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Secure Login Demonstration</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="bg-white p-8 rounded-lg shadow-md w-96">
        <h2 class="text-2xl font-bold mb-6 text-center">Secure Login</h2>
        
        <form id="loginForm" class="space-y-4">
            <div>
                <label for="username" class="block text-sm font-medium text-gray-700">Username</label>
                <input 
                    type="text" 
                    id="username" 
                    name="username" 
                    required 
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
                >
            </div>
            
            <div>
                <label for="password" class="block text-sm font-medium text-gray-700">Password</label>
                <input 
                    type="password" 
                    id="password" 
                    name="password" 
                    required 
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
                >
            </div>
            
            <div id="securityNotices" class="text-sm text-yellow-600"></div>
            
            <button 
                type="submit" 
                class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500"
            >
                Login
            </button>
        </form>
    </div>

    <script>
    // Secure Input Protection
    class SecureInput {
        constructor(inputElement) {
            this.input = inputElement;
            this._sensitiveValue = new WeakMap();
            this.protectInput();
        }

        protectInput() {
            Object.defineProperty(this.input, 'value', {
                get: () => {
                    console.warn('Direct value access blocked');
                    return '';
                },
                set: (newValue) => {
                    this._sensitiveValue.set(this.input, this.encrypt(newValue));
                }
            });
        }

        getValue() {
            const encryptedValue = this._sensitiveValue.get(this.input);
            return encryptedValue ? this.decrypt(encryptedValue) : '';
        }

        encrypt(value) {
            // Simple XOR encryption (for demonstration)
            return btoa(value.split('').map(char => 
                String.fromCharCode(char.charCodeAt(0) ^ 0x55)
            ).join(''));
        }

        decrypt(encodedValue) {
            return atob(encodedValue).split('').map(char => 
                String.fromCharCode(char.charCodeAt(0) ^ 0x55)
            ).join('');
        }
    }

    // Nonce Protection for Password
    class NonceProtection {
        static generateNonce() {
            return Math.random().toString(36).substring(2, 15);
        }

        static injectNonce(passwordField) {
            const originalPassword = passwordField.value;
            const nonce = this.generateNonce();
            
            // Replace with nonce
            passwordField.value = nonce;
            
            // Securely store original password
            sessionStorage.setItem('__secure_password', btoa(originalPassword));

            return nonce;
        }

        static retrieveOriginalPassword() {
            const storedPassword = sessionStorage.getItem('__secure_password');
            return storedPassword ? atob(storedPassword) : null;
        }
    }

    // Extension and Input Security Monitor
    class SecurityMonitor {
        static detectExtensionTampering(inputElement) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes') {
                        console.warn('Potential element tampering detected');
                        document.getElementById('securityNotices').textContent = 
                            'Warning: Suspicious activity detected!';
                    }
                });
            });

            observer.observe(inputElement, { 
                attributes: true, 
                attributeFilter: ['type', 'class'] 
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const loginForm = document.getElementById('loginForm');

        // Secure username input
        const secureUsername = new SecureInput(usernameInput);

        // Secure password input with nonce
        const securePassword = new SecureInput(passwordInput);

        // Monitor for suspicious activities
        SecurityMonitor.detectExtensionTampering(passwordInput);

        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();

            // Inject nonce for password
            const passwordNonce = NonceProtection.injectNonce(passwordInput);

            // Simulate server-side validation
            setTimeout(() => {
                const originalPassword = NonceProtection.retrieveOriginalPassword();
                
                if (originalPassword) {
                    console.log('Login attempted with secure credentials');
                    alert('Login simulation successful with enhanced security!');
                } else {
                    alert('Security validation failed');
                }
            }, 500);
        });
    });
    </script>
</body>
</html>